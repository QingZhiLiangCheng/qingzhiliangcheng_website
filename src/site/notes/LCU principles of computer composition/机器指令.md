---
{"dg-publish":true,"permalink":"/LCU principles of computer composition/机器指令/","dgPassFrontmatter":true,"noteIcon":"","created":"2024-11-26T18:57:31.089+08:00","updated":"2025-03-30T15:07:05.419+08:00"}
---


这一部分我在CSAPP中接触到一部分
所谓的机器指令 就是 CPU能够直接识别并且执行的操作系统
一个机器所能操作的所有机器指令的结合--->称作指令集
指令集是软件和硬件的交接面
软件通过指令系统告诉计算机的硬件做什么操作
硬件通过指令系统将硬件的运行结果和硬件的状态返回给软件

机器指令 怎么设计？   哪些类型？   具体怎么操作？
在计算机组成中 就是把这些计算机系统设计人员所设计的   利用逻辑单元进行实现

第一步要先了解指令
- 指令格式：   操作码   地址码   寻址方式
	操作码：做的什么操作  对什么样的数据进行操作
	地址码：对谁进行操作
	编程的方便     ---  寻址方式
- 指令字长
	固定字长、可变字长


### 指令的一般格式
![Pasted image 20241126190919.png|300](/img/user/accessory/Pasted%20image%2020241126190919.png)
- 操作码
	反映机器做什么操作
	对什么样的数据进行操作
	长度固定的     ----   便于译码
	长度可变      ----- x86
	为了实现操作码的长度可变：扩展操作码技术
		1. 保留一个编码的码点作为扩展的标志
			![Pasted image 20241126191632.png|400](/img/user/accessory/Pasted%20image%2020241126191632.png)
			由于指令的长度是不变的，假设图中的操作码和三个地址分别都是4位
			那么如果没有扩展操作码技术的话，只能表示16条指令
			所谓的保留一个码点作为扩展的标志的方式，就是说我通过牺牲地址指令的长度 并当最后四位是四个1的时候 放弃一个地址指令 来编码的一种方式
			为了让计算机知道操作码的位数   ----- 短操作码不能是长操作码的前缀 ---赫夫曼
			高频指令---短操作码    低频指令----长操作码
		2.  某一位作为扩展的标志（教材上没介绍）
- 地址码
	1. 四地址
		![Pasted image 20241126192606.png|200](/img/user/accessory/Pasted%20image%2020241126192606.png)
		取地址  取操作数A1  A2   存结果   四次访存
		如果设指令字长为32位  操作码固定为8位   那么  地址码地址为24位  平分后每个分6位
		寻址范围 64   非常小
		可以放弃a4   因为现代计算机中下一条的指令在pc中
	2. 三地址
		![Pasted image 20241126192946.png|200](/img/user/accessory/Pasted%20image%2020241126192946.png)
		还是4次访存
		寻址范围  256
		我们可以把a2 或者 a1 来代替  a3   换句话说就是算完了再存回去
	3. 两地址
		![Pasted image 20241126194229.png|200](/img/user/accessory/Pasted%20image%2020241126194229.png)
		4次访存
		寻址范围 4K
		如果最后结果不保存在a1 和 a2  而是保存在特定的寄存器的话比如ACC  那就是3次访存
	4. 一地址
		某一个操作数在ACC中
		![Pasted image 20241126194512.png|200](/img/user/accessory/Pasted%20image%2020241126194512.png)
		2次访存      寻址范围16M
	5. 零地址
		ACC取反      判断   等等
		堆栈类 add  栈顶做加法保存在栈顶

### 指令字长
![Pasted image 20241126194856.png|400](/img/user/accessory/Pasted%20image%2020241126194856.png)
